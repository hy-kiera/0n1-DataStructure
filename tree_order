// BAEKJOON 1991번
// 이진 트리를 입력받아 전위 순회(preorder traversal), 중위 순회(inorder traversal), 후위 순회(postorder traversal)한 결과 출력

// 입력
// 첫째 줄에는 이진 트리의 노드의 개수 N(1≤N≤26)이 주어진다.
// 둘째 줄부터 N개의 줄에 걸쳐 각 노드와 그의 왼쪽 자식 노드, 오른쪽 자식 노드가 주어진다.
// 노드의 이름은 A부터 차례대로 영문자 대문자로 매겨지며, 항상 A가 루트 노드가 된다.
// 자식 노드가 없는 경우에는 .으로 표현된다.

// 출력
// 첫째 줄에 전위 순회, 둘째 줄에 중위 순회, 셋째 줄에 후위 순회한 결과를 출력한다.
// 각 줄에 N개의 알파벳을 공백 없이 출력

#include <cstdio>
#include <vector>

using namespace std;

// vector <pair<int, int> > tree;  //2개
// vector <vector<int> > tree;  //n개

vector <pair<int, int> > tree(30);

void preorder(int root){
	if(root<0) return;
	printf("%c", root+'A');
	preorder(tree[root].first);
	preorder(tree[root].second);
}

void inorder(int root){
	if(root<0) return;
	inorder(tree[root].first);
	printf("%c", root+'A');
	inorder(tree[root].second);
}

void postorder(int root){
	if(root<0) return;
	postorder(tree[root].first);
	postorder(tree[root].second);
	printf("%c", root+'A');
}

int main(){
	int n;
	scanf("%d", &n);

	for(int i=0;i<n;i++){
		char a,b,c;
		scanf(" %c %c %c", &a, &b, &c);  //입력받을 때 엔터 값을 넣기 위해 ' '띄어쓰기 한다.
		tree[a-'A'].first = b-'A';
		tree[a-'A'].second = c-'A';
	}
	preorder(0);
	printf("\n");
	inorder(0);
	printf("\n");
	postorder(0);
	printf("\n");
	return 0;
}
