// BAEKJOON 2250번
// 이진트리를 다음의 규칙에 따라 행과 열에 번호가 붙어있는 격자 모양의 틀 속에 그리려고 한다. 이 때 다음의 규칙에 따라 그리려고 한다.
// 1. 이진트리에서 같은 레벨(level)에 있는 노드는 같은 행에 위치한다.
// 2. 한 열에는 한 노드만 존재한다.
// 3. 임의의 노드의 왼쪽 부트리(left subtree)에 있는 노드들은 해당 노드보다 왼쪽의 열에 위치하고, 오른쪽 부트리(right subtree)에 있는 노드들은 해당 노드보다 오른쪽의 열에 위치한다.
// 4. 노드가 배치된 가장 왼쪽 열과 오른쪽 열 사이엔 아무 노드도 없이 비어있는 열은 없다.
// 5. 너비가 가장 넓은 레벨이 두 개 이상 있을 때는 번호가 작은 레벨을 답으로 한다. 

// 입력
// 첫째 줄에 노드의 개수를 나타내는 정수 N(1 ≤ N ≤ 10,000)이 주어진다.
// 다음 N개의 줄에는 각 줄마다 노드 번호와 해당 노드의 왼쪽 자식 노드와 오른쪽 자식 노드의 번호가 순서대로 주어진다.
// 노드들의 번호는 1부터 N까지이며, 자식이 없는 경우에는 자식 노드의 번호에 -1이 주어진다.

// 출력
// 첫째 줄에 너비가 가장 넓은 레벨과 그 레벨의 너비를 순서대로 출력한다.
// 너비가 가장 넓은 레벨이 두 개 이상 있을 때에는 번호가 작은 레벨을 출력한다.

#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

vector <pair<int, int> > tree(20017);
vector <pair<int, int> > lr(20017);
vector <vector<int> > name(20017);

vector <int> q(20017);

int w=0, h=0;

void inorder(int root){
	if(root<0){
		return;
	}
	h++;
	inorder(lr[root].first);
	w++;
	tree[root].first=h;
	tree[root].second=w;
	inorder(lr[root].second);
	h--;
}

int main(){
	int n, max=-1, maxj, rtnum;
	scanf("%d", &n);

	for(int i=0;i<n;i++){
		int a,b,c;
		scanf(" %d %d %d", &a, &b, &c);
		lr[a].first = b;
		lr[a].second = c;
		if(i==0){
			rtnum=a;
		}
	}

	inorder(rtnum);

	sort(tree.begin(), tree.begin()+n);

	for(int i=1;i<=n;i++){
		name[tree[i].first].push_back(tree[i].second);
	}

	int height=tree[n].first;

	for(int j=1;j<=height;j++){
		int index=name[j].size();
		int begin=name[j][0];
		int end=name[j][index-1];

		int dis=end-begin+1;
		if(dis>max){
			max=dis;
			maxj=j;
		}
	}

	printf("%d %d", maxj, max);

	return 0;
}
