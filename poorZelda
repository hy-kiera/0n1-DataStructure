// BAEKJOON 4485번
// 젤다의 전설 게임에서 화폐의 단위는 루피(rupee)다.
// 그런데 간혹 '도둑루피'라 불리는 검정색 루피도 존재하는데, 이걸 획득하면 오히려 소지한 루피가 감소하게 된다!
// 젤다의 전설 시리즈의 주인공, 링크는 지금 도둑루피만 가득한 N x N 크기의 동굴의 제일 왼쪽 위([0][0])에 있다.
// 링크는 이 동굴의 반대편 출구, 제일 오른쪽 아래 칸인 [N-1][N-1]까지 이동해야 한다.
// 동굴의 각 칸마다 도둑루피가 있는데, 이 칸을 지나면 해당 도둑루피의 크기만큼 소지금을 잃게 된다.
// 링크는 잃는 금액을 최소로 하여 동굴 건너편까지 이동해야 하며, 한 번에 상하좌우 인접한 곳으로 1칸씩 이동할 수 있다.
// 링크가 잃을 수 밖에 없는 최소 금액을 구하라.

// 입력
// 입력은 여러 개의 테스트 케이스로 이루어져 있다.
// 각 테스트 케이스의 첫째 줄에는 동굴의 크기를 나타내는 정수 N이 주어진다.(2 ≤ N ≤ 125)
// N = 0인 입력이 주어지면 전체 입력이 종료된다.
// N개의 줄에 걸쳐 동굴의 각 칸에 있는 도둑루피의 크기가 공백으로 구분되어 차례대로 주어진다.
// 도둑루피의 크기가 k면 이 칸을 지나면 k루피를 잃는다는 뜻이다.
// 주어지는 모든 정수는 0 이상 9 이하인 한 자리 수다.

// 출력
// 각 테스트 케이스마다 한 줄에 걸쳐 정답을 형식(problem i:)에 맞춰서 출력한다.

#include <cstdio>
#include <queue>
#include <vector>
#include <algorithm>
#define INF 300000000

using namespace std;

int N;

vector <vector <pair<int, int> > > mat(20017);

vector<int> dijkstra(int s){
	priority_queue <pair<int,int>, vector <pair<int,int> >, greater<pair <int,int> > > pq;
	vector <int> dist(N*N, INF);
	dist[s]=0;
	pq.push(make_pair(0,s));
	while(!pq.empty()){
		int cost = pq.top().first, here = pq.top().second;
		pq.pop();
		if(dist[here]<cost) continue;
		for(int i=0;i<mat[here].size();i++){
			int nextcost= cost + mat[here][i].second;
			int there=mat[here][i].first;
			if(dist[there]>nextcost){
				dist[there]=nextcost;
				pq.push(make_pair(nextcost,there));
			}
		}
	}
	return dist;
}

int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};  //하 상 우 좌
int map[150][150];
int cnt=0;

int main(){
	while(1){
		cnt++;
		scanf("%d",&N);

		if(N<=0){
			break;
		}

		for(int i=0;i<N;i++){
			for(int j=0;j<N;j++){
				scanf(" %d", &map[i][j]);
			}
		}

		int s=0;
		for(int i=0;i<N;i++){
			for(int j=0;j<N;j++){
				for(int a=0;a<4;a++){
					int y=i+dir[a][0], x=j+dir[a][1];
					if(y<0 || y>=N || x<0 || x>=N) continue; //mat[s].push_back(make_pair(INF, INF));
					else if(y-1==i && x==j){ //하
						mat[s].push_back(make_pair(s+N, map[i+1][j]));
						// printf("%d to %d rupy=%d\n", s, s+N, map[i+1][j]);
					}
					else if(y+1==i && x==j){ //상
						mat[s].push_back(make_pair(s-N, map[i-1][j]));
						// printf("%d to %d rupy=%d\n", s, s-N, map[i-1][j]);
					}
					else if(y==i && x-1==j){ //우
						mat[s].push_back(make_pair(s+1, map[i][j+1]));
						// printf("%d to %d rupy=%d\n", s, s+1, map[i][j+1]);
					}
					else if(y==i && x+1==j){ //좌
						mat[s].push_back(make_pair(s-1, map[i][j-1]));
						// printf("%d to %d rupy=%d\n", s, s-1, map[i][j-1]);
					}
				}
				s++;
			}
		}

		vector <int> res;

		res=dijkstra(0);

		printf("Problem %d: %d\n", cnt, res[N*N-1]+map[0][0]);

		for(int i=0;i<mat.size();i++){
			mat[i].clear();
		}
	}

	return 0;
}
